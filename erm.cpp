#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>
#include <limits>
#include <cmath>
#include "rapidjson/include/rapidjson/allocators.h"
#include "rapidjson/include/rapidjson/stringbuffer.h"
#include "rapidjson/include/rapidjson/writer.h"
#include "rapidjson/include/rapidjson/document.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <memory>
#include <algorithm>
#include <random>
#include <chrono> 
#include <ctime> 

using namespace std;
using namespace rapidjson;
struct node;
struct ranking;
struct push;
struct gooInput;
struct parsed_table;
struct parsed_join;
struct parsed_size;
struct parsed_file;
class node;
class node_stats;

std::vector<int> combine(std::vector<int> v1, std::vector<int> v2);
long double hj(long double card1, long double card2, long double pred);
long double getPred(long double **adj, const std::vector<int> &left, const std::vector<int> &right);
std::string combineName(std::string left, std::string right);
long double ij(long double p1, int t2, long double sel, int lambda);
node *getBestPush(node *l, node *r, long double **adj);
gooInput generateGooInput(std::vector<parsed_table> tables, std::vector<parsed_join> joins, std::vector<parsed_size> sizes);
parsed_file parseFile(string filepath);
gooInput autoGeneratedGoo(int size);
class node_stats {
public:
	long double card;
	// this is the cost kinda consitently mistyped once had to keep it :(
	long double rank;
	long double predicate;
	bool isTable;
	bool index;
	int org_card;
	std::vector<int> content;
	std::string name;

	node_stats(long double icard, long double irank, long double ipredicate, bool iisTable, bool iindex, int iorg_card,
		std::vector<int> icontent, std::string iname) {
		card = icard;
		rank = irank;
		predicate = ipredicate;
		isTable = iisTable;
		org_card = iorg_card;
		content = icontent;
		name = iname;
		index = iindex;
	}
};
struct parsed_table {
public:
	string name;
	string baseTable;
	int cardinality;
	int unfilteredCardinality;
};
struct parsed_join {
public:
	string left;
	string right;
};

struct parsed_size {
public:
	int cardinality;
	string left;
	string right;
};
struct parsed_file {
public:
	vector<parsed_table> pt;
	vector<parsed_size> ps;
	vector<parsed_join> pj;
};
struct ranking {
public:
	bool swap;
	bool index;
	long double rank;
	long double card;
};
struct pusheru {
public:
	node *n;
	long double rank;
};
struct gooInput {
public:
	int size;
	int *tables;
	long double **adj;
};
class node {
public:
	node *p;
	node *l;
	node *r;
	node_stats *main;
	node_stats *temp = nullptr;
	node(node *ip, node *il, node *ir, node_stats *imain) {
		p = ip;
		l = il;
		r = ir;
		main = imain;
		resetTemp();
	}
	void incrementParent() {
	}
	// gets best cost for hj and ij
	ranking generalCostFunction(node *left, node *right, long double pred) {
		ranking rnk;
		rnk.card = hj(left->main->card, right->main->card, pred);
		rnk.rank = rnk.card + left->main->rank + right->main->rank;
		rnk.index = false;
		rnk.swap = right->main->card < left->main->card;

		ranking temp;
		if (right->main->isTable) {
			temp.card = ij(left->main->card, right->main->org_card, pred, 2);
			temp.rank = temp.card + left->main->rank;
			temp.index = true;
			temp.swap = false;
			if (temp.rank < rnk.rank) {
				rnk = temp;
			}
		}
		if (left->main->isTable) {
			temp.card = ij(right->main->card, left->main->org_card, pred, 2);
			temp.rank = temp.card + right->main->rank;
			temp.index = true;
			temp.swap = true;
			if (temp.rank < rnk.rank) {
				rnk = temp;
			}
		}
		return rnk;
	}
	ranking tempCostFunction(node *left, node *right, long double pred) {
		ranking r;
		r.card = hj(left->temp->card, right->temp->card, pred);
		r.rank = r.card + left->temp->rank + right->temp->rank;
		r.index = false;
		r.swap = right->temp->card < left->temp->card;

		ranking temp;
		if (right->temp->isTable) {
			temp.card = ij(left->temp->card, right->temp->org_card, pred, 2);
			temp.rank = temp.card + left->temp->rank;
			temp.index = true;
			temp.swap = false;
			if (temp.rank < r.rank) {
				r = temp;
			}
		}
		if (left->temp->isTable) {
			temp.card = ij(right->temp->card, left->temp->org_card, pred, 2);
			temp.rank = temp.card + right->temp->rank;
			temp.index = true;
			temp.swap = true;
			if (temp.rank < r.rank) {
				r = temp;
			}
		}
		return r;
	}
	// TODO  ready ?s
	pusheru getPush(node *tree, node *push, long double **adj) {
		pusheru push_res;
		tree->resetTemp();
		push->resetTemp();
		// pushed on node pretends to be its new inserted
		long double pred = getPred(adj, this->temp->content, push->temp->content);
		ranking rnk = tempCostFunction(this, push, pred);
		node *temp = this;
		temp->temp->rank = rnk.rank;
		temp->temp->card = rnk.card;
		temp->temp->isTable = false;
		temp->temp->content = combine(this->temp->content, push->temp->content);
		while (temp->p != nullptr) {
			temp = temp->p;
			pred = getPred(adj, temp->l->temp->content, temp->r->temp->content);
			rnk = tempCostFunction(temp->r, temp->l, pred);
			temp->temp->rank = rnk.rank;
			temp->temp->card = rnk.card;
			// temp->temp->isTable = false;
			temp->temp->content = combine(temp->l->temp->content, temp->r->temp->content);
		}
		push_res.rank = rnk.rank;
		push_res.n = this;
		pusheru temp_result;
		if (this->r != nullptr && this->r != nullptr) {
			temp_result = this->r->getPush(tree, push, adj);
			if (temp_result.rank < push_res.rank) {
				push_res = temp_result;
			}
			temp_result = this->l->getPush(tree, push, adj);
			if (temp_result.rank < push_res.rank) {
				push_res = temp_result;
			}
		}
		return push_res;
	}
	void applyPush(node *push, long double **adj) {
		long double pred = getPred(adj, this->temp->content, push->temp->content);
		ranking rnk = generalCostFunction(this, push, pred);

		node *l;
		node *r;
		if (rnk.swap) {
			l = push;
			r = this;
		}
		else {
			l = this;
			r = push;
		}
		std::string name = combineName(l->main->name, r->main->name);
		std::vector<int> content = combine(l->main->content, r->main->content);
		// TODO
		node_stats *stats = new node_stats(rnk.card, rnk.rank, pred, false, rnk.index, -1, content, name);
		node *build = new node(this->p, l, r, stats);
		// incrementally adjust rank and card
		node *temp = build;
		while (temp->p != nullptr) {
			temp = temp->p;
			pred = getPred(adj, temp->l->temp->content, temp->r->temp->content);
			rnk = generalCostFunction(temp->l, temp->r, pred);
			if (rnk.swap) {
				node *save = temp->l;
				temp->l = temp->r;
				temp->r = save;
			}
			temp->main->rank = rnk.rank;
			temp->main->card = rnk.card;
			temp->main->index = rnk.index;
			temp->main->name = combineName(temp->l->main->name, temp->r->main->name);
			temp->main->content = combine(temp->l->main->content, temp->r->main->content);
		}
	}
	void removeTempTable(node *tree, node *table, long double **adj) {
		node *temp = table->p;
		// temporarily see table x P2 as P2
		if (table->p->r == table) {
			temp->temp = table->l->temp;
		}
		else {
			temp->temp = table->r->temp;
		}
		ranking rnk;
		while (temp->p != nullptr) {
			temp = temp->p;
			long double pred = getPred(adj, temp->l->temp->content, temp->r->temp->content);
			rnk = tempCostFunction(temp->r, temp->l, pred);
			temp->temp->rank = rnk.rank;
			temp->temp->card = rnk.card;
			temp->temp->index = rnk.index;
			// temp->temp->isTable = false;
			temp->temp->content = combine(temp->l->temp->content, temp->r->temp->content);
		}
	}
	void removeTable(node *tree, node *table, long double **adj) {
		node *remove = table->p;
		// temporarily see table x P2 as P2
		node *replace;
		if (remove->r == table) {
			replace = remove->l;
		}
		else {
			replace = remove->r;
		}
		if (remove->p->r == remove) {
			remove->p->r = replace;
		}
		else {
			remove->p->l = replace;
		}
		replace->p = remove->p;
		remove->freeComponents();
		free(remove);
		node *temp = replace;
		while (temp->p != nullptr) {
			long double pred = getPred(adj, temp->l->main->content, temp->r->main->content);
			ranking rnk = generalCostFunction(temp->l, temp->r, pred);
			if (rnk.swap) {
				node *save = temp->l;
				temp->l = temp->r;
				temp->r = save;
			}
			temp->main->card = rnk.card;
			temp->main->rank = rnk.rank;
			temp->main->predicate = pred;
			// temp->main->isTable = false;
			// temp->main->org_card = -1;
			temp->main->content = combine(temp->l->main->content, temp->r->main->content);
			temp->main->name = combineName(temp->l->main->name, temp->r->main->name);
			temp->main->index = rnk.index;
		}
	}
	// try allpushes top to bottom and take the best
	pusheru getPull(node *tree, node *table, long double **adj) {
		tree->resetTemp();
		table->resetTemp();
		// removeTempTable(tree,table,adj);
		pusheru res;
		long double pred = getPred(adj, this->temp->content, table->temp->content);
		ranking rnk = tempCostFunction(this, table, pred);
		this->temp->rank = rnk.rank;
		this->temp->card = rnk.card;
		this->temp->isTable = false;
		this->temp->index = rnk.index;
		node *temp = this;
		// TODO this is always the same maby save 100 lines
		while (temp->p != nullptr) {
			temp = temp->p;
			pred = getPred(adj, temp->l->temp->content, temp->r->temp->content);
			rnk = tempCostFunction(temp->r, temp->l, pred);
			temp->temp->rank = rnk.rank;
			temp->temp->card = rnk.card;
			temp->temp->index = rnk.index;
			// temp->temp->isTable = false;
			temp->temp->content = combine(temp->l->temp->content, temp->r->temp->content);
		}
		res.rank = rnk.rank;
		res.n = this;
		pusheru temp_push;
		temp_push = this->l->getPull(tree, table, adj);
		if (temp_push.rank < res.rank) {
			res = temp_push;
		}
		temp_push = this->r->getPull(tree, table, adj);
		if (temp_push.rank < res.rank) {
			res = temp_push;
		}
		return res;
	}
	// gets best pull for one table
	void getBestPull(long double **adj, node *tree, node *table) {
		removeTable(tree, table, adj);
		pusheru res;
		res = tree->getPull(tree, table, adj);

		long double pred = getPred(adj, res.n->main->content, table->main->content);
		ranking rnk = generalCostFunction(res.n, table, pred);

		node *l;
		node *r;
		if (rnk.swap) {
			l = tree;
			r = res.n;
		}
		else {
			l = res.n;
			r = tree;
		}
		std::vector<int> content = combine(l->main->content, r->main->content);
		std::string name = combineName(l->main->name, r->main->name);
		node_stats *stats = new node_stats(rnk.card, rnk.rank, pred, false, rnk.index, -1, content, name);
		node *build = new node(res.n->p, l, r, stats);

		node *temp = build;
		// copied from push
		while (temp->p != nullptr) {
			temp = temp->p;
			long double pred = getPred(adj, temp->l->temp->content, temp->r->temp->content);
			rnk = generalCostFunction(temp->l, temp->r, pred);
			if (rnk.swap) {
				node *save = temp->l;
				temp->l = temp->r;
				temp->r = save;
			}
			temp->main->rank = rnk.rank;
			temp->main->card = rnk.card;
			temp->main->index = rnk.index;
			temp->main->name = combineName(temp->l->main->name, temp->r->main->name);
			temp->main->content = combine(temp->l->main->content, temp->r->main->content);
		}
	}
	void resetTemp() {
		if (temp != nullptr) {
			free(temp);
		}
		temp = new node_stats(main->card, main->rank, main->predicate, main->isTable, main->index, main->org_card, main->content,
			main->name);
	}
	void freeComponents() {
		free(main);
		free(temp);
	}
	void freeTree() {
		if (this->l != nullptr && this->r != nullptr) {
			this->l->freeTree();
			this->r->freeTree();
		}
		this->freeComponents();
		free(this);
	}
	// cacluclates the cost/rank top down
	long double calcRank(long double rank) {
		// TODO need help here first apporach didnt work is this one correct now ?
		if (main->isTable) {
			return rank + main->card;
		}
		if (main->index) {
			return l->calcRank(rank + main->card);
		}
		else {
			return l->calcRank(rank + main->card) + r->calcRank(rank + main->card);
		}
	}
};
struct table {
public:
	int card;
	std::string name;
};

class DP {
	using Node = node;
	struct Plan {
		vector<int> covered;
		unique_ptr<Node> node;
		unique_ptr<node_stats> stats;

		Plan(vector<int> covered, unique_ptr<Node> node, unique_ptr<node_stats> stats)
			: covered(covered), node(move(node)), stats(move(stats)) {
		}
	};

	gooInput querygraph;
	vector<vector<Plan *>> plans;
	unordered_map<vector<bool>, unique_ptr<Plan>> dptable;

	static bool disjoint(const Plan &left, const Plan &right) {
		vector<int> intersection;
		set_intersection(left.covered.begin(), left.covered.end(), right.covered.begin(), right.covered.end(),
			back_inserter(intersection));
		return intersection.empty();
	}

	bool connected(const Plan &left, const Plan &right) const {
		for (auto l : left.covered) {
			for (auto r : right.covered) {
				if (querygraph.adj[l][r] < 1.0)
					return true;
			}
		}
		return false;
	}

	void buildPlan(const Plan &left, const Plan &right, double sel) {
		if (disjoint(left, right) && connected(left, right)) {
			auto sel = getPred(querygraph.adj, left.covered, right.covered);
			vector<int> total;
			set_union(left.covered.begin(), left.covered.end(), right.covered.begin(), right.covered.end(), back_inserter(total));
			vector<bool> bits;
			bits.resize(querygraph.size);
			for (auto i : total) {
				bits[i] = true;
			}
			auto card = hj(left.node->main->card, right.node->main->card, sel);
			auto cost = card + left.stats->rank + right.stats->rank;
			auto stats = make_unique<node_stats>(card, cost, sel, false, false, -1, total,
				combineName(left.node->main->name, right.node->main->name));
			auto statsptr = stats.get();
			auto &plan = dptable[bits];
			if (plan == nullptr) {
				auto newplan =
					make_unique<Plan>(total, make_unique<Node>(nullptr, left.node.get(), right.node.get(), statsptr), move(stats));
				plans[total.size() - 1].push_back(newplan.get());
				dptable[bits] = move(newplan);
			}
			else if (cost < plan->stats->rank) {
				dptable[bits]->stats = move(stats);
				dptable[bits]->node = make_unique<Node>(nullptr, left.node.get(), right.node.get(), statsptr);
			}
		}
	}

public:
	DP(gooInput querygraph) : querygraph(querygraph) {
		plans.resize(querygraph.size);
		// seed base relations into dp table
		for (int i = 0; i < querygraph.size; ++i) {
			long double card = querygraph.tables[i] * querygraph.adj[i][i];
			std::vector<int> content;
			content.push_back(i);
			auto stats =
				make_unique<node_stats>(card, card, querygraph.adj[i][i], true, false, querygraph.tables[i], content, to_string(i));
			auto statsptr = stats.get();
			vector<bool> bits;
			bits.resize(querygraph.size);
			bits[i] = true;
			auto plan = make_unique<Plan>(content, make_unique<Node>(nullptr, nullptr, nullptr, statsptr), move(stats));
			plans[0].emplace_back(plan.get());
			dptable.emplace(bits, move(plan));
		}
	}
	node *run() {
		for (int size = 1; size <= querygraph.size; ++size) {
			for (int i = 0; i < size; ++i) {
				for (const auto &left : plans[i]) {
					for (const auto &right : plans[size - i - 1]) {
						buildPlan(*left, *right, getPred(querygraph.adj, left->covered, right->covered));
					}
				}
			}
		}

		vector<bool> total(querygraph.size, true);
		auto &result = dptable[total];
		return result->node.get();
	}
};

class optimizer {
public:
	long double **adj;
	std::vector<node *> plans;
	std::vector<node *> table_save;
	int N;
	void freeOptimizer() {
		free(adj);
	}
	optimizer(int iN, long double **adj_in, int *tables) {
		int N = iN;
		adj = new long double *[N];
		for (int i = 0; i < N; i++) {
			adj[i] = new long double[N];
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				adj[i][j] = adj_in[i][j];
			}
		}
		for (int i = 0; i < N; i++) {
			long double card = tables[i] * adj[i][i];
			std::vector<int> content;
			content.push_back(i);
			node_stats *stats = new node_stats(card, card, adj[i][i], true, false, tables[i], content, to_string(i));
			node *table = new node(nullptr, nullptr, nullptr, stats);
			plans.push_back(table);
		}
		table_save = plans;
	}
	optimizer(std::vector<parsed_table> tables, std::vector<parsed_join> joins, std::vector<parsed_size> sizes) {
		adj = new long double *[tables.size()];
		for (int i = 0; i < tables.size(); i++) {
			adj[i] = new long double[tables.size()];
		}
		for (int i = 0; i < tables.size(); i++) {
			for (int j = 0; j < tables.size(); j++) {
				adj[i][j] = 1.0;
			}
		}

		for (int i = 0; i < tables.size(); i++) {
			std::vector<int> content;
			content.push_back(i);
			parsed_table pt = tables.at(i);
			adj[i][i] = (long double)pt.cardinality / pt.unfilteredCardinality;
			node_stats *stats = new node_stats(pt.cardinality, pt.cardinality, (long double)(pt.cardinality) / pt.unfilteredCardinality,
				true, false, pt.unfilteredCardinality, content, pt.name);

			node *table = new node(nullptr, nullptr, nullptr, stats);
			// cout<< "number: "+ to_string(i) + " card: " +to_string(table->main->card)+ table->main->name<<endl;
			plans.push_back(table);
		}
		// do with hash table or sth
		for (int i = 0; i < sizes.size(); i++) {
			parsed_size ps = sizes.at(i);
			int left;
			int right;
			for (int j = 0; j < tables.size(); j++) {
				if (ps.left.compare(tables.at(j).name) == 0) {
					left = j;
					break;
				}
			}
			for (int j = 0; j < tables.size(); j++) {
				if (ps.right.compare(tables.at(j).name) == 0) {
					right = j;
					break;
				}
			}
			adj[left][right] = 1.0 * ps.cardinality / (tables.at(left).cardinality * tables.at(right).cardinality);
			adj[right][left] = 1.0 * ps.cardinality / (tables.at(left).cardinality * tables.at(right).cardinality);

			// cout<<to_string(adj[right][left])+"adj und rechnung "+to_string((long
			// double)(ps.cardinality)/(tables.at(left).cardinality*tables.at(right).cardinality))<<endl;
			// cout<<"ps.card "+to_string(ps.cardinality)+" left card: "+to_string(tables.at(left).cardinality)+" right card: "
			// +to_string(tables.at(right).cardinality)  <<endl;
		}
		for (int i = 0; i < tables.size(); i++) {
			for (int j = 0; j < tables.size(); j++) {
				// cout<<to_string(adj[i][j])+" ";
			}
			// cout<< "" <<endl;
		}
		table_save = plans;
	}
	// TODO Ask why N turns into ifinity
	node *optimize(bool index, bool push, bool pull) {
		if (push || pull) {
			index = true;
		}
		// cout<<"plansize"+to_string(plans.size())<<endl;
		for (int n = plans.size() - 1; n > 0; n--) {
			// cout<<"n"+to_string(plans.size()-1)+"n"+to_string(N)<<endl;
			long double min_rank = std::numeric_limits<long double>::infinity();
			long double temp_rank;
			// TODO  how do we do indexes ?
			// take best of cost considering indexes?
			int min_right;
			int min_left;
			long double best_pred;
			ranking cost;
			ranking temp_cost;
			// cout<< "bevore loop"<<endl;
			for (int left = 0; left < n; left++) {
				for (int right = left + 1; right <= n; right++) {
					// enumerate+rank
					// cout<<"a"+to_string(left)+"b"+to_string(right)<<endl;
					if (index) {
						// TODO
						long double pred = getPred(adj, plans.at(left)->main->content, plans.at(right)->main->content);
						// TODO no idea how abstract functions work in c++

						temp_cost = plans.at(left)->generalCostFunction(plans.at(left), plans.at(right), pred);
						if (temp_cost.rank < min_rank) {
							min_right = right;
							min_left = left;
							min_rank = temp_cost.rank;
							cost = temp_cost;
						}
						//						cout<<"card 1: "+std::to_string( plans.at(left)->main->card )+" rank1:
						//"+std::to_string( plans.at(left)->main->rank)+" card 2: "+std::to_string( plans.at(right)->main->card)+" rank2:
						// "+std::to_string( plans.at(right)->main->rank)<<endl;

					}
					else {
						// TODO replace no not have extra quadratic (should be kinda ez)
						long double pred = getPred(adj, plans.at(left)->main->content, plans.at(right)->main->content);
						temp_rank = hj(plans.at(right)->main->card, plans.at(left)->main->card, pred);
						if (temp_rank < min_rank) {
							min_rank = temp_rank;
							min_right = right;
							min_left = left;
							best_pred = pred;
						}

					} // if index
				}   // for 2
			}     // for 1
			// merge
			// cout<<"left: "+plans.at(min_left)->main->name+"right: "+plans.at(min_right)->main->name<<endl;
			// cout << "left: " + std::to_string(min_left)+ " right: " +std::to_string(min_right)+ " new rank: "+std::to_string(min_rank)
			// +" new card: "+std::to_string(cost.card)<<endl;
			node *build;
			if (push) {
				build = getBestPush(plans.at(min_left), plans.at(min_right), adj);
				plans.at(min_right) = plans.at(n);
				plans.at(min_left) = build;
			}
			else {
				if (index) {
					// dont forget to add rank
					std::string name;
					std::vector<int> content;
					node *l;
					node *r;

					if (!cost.swap) {
						l = plans.at(min_left);
						r = plans.at(min_right);
					}
					else {
						l = plans.at(min_right);
						r = plans.at(min_left);
					}
					// cout<<"left rank: "+ std::to_string(l->main->rank)+"left card: "+std::to_string(l->main->card)<<endl;
					// cout<< "right rank: "+ std::to_string(r->main->rank)+"right card: "+std::to_string(r->main->card)<<endl;
					name = combineName(l->main->name, r->main->name);
					content = combine(l->main->content, r->main->content);
					node_stats *stats = new node_stats(cost.card, cost.rank, best_pred, false, cost.index, -1, content, name);
					build = new node(nullptr, l, r, stats);
					plans.at(min_right) = plans.at(n);
					plans.at(min_left) = build;

				}
				else {
					std::vector<int> build_content = combine(plans.at(min_left)->main->content, plans.at(min_right)->main->content);
					std::string build_name;
					long double rank = min_rank + plans.at(min_left)->main->rank + plans.at(min_right)->main->rank;
					if (plans.at(min_left)->main->card < plans.at(min_right)->main->card) {
						build_name = combineName(plans.at(min_left)->main->name, plans.at(min_right)->main->name);
						node_stats *stats = new node_stats(min_rank, rank, best_pred, false, false, -1, build_content, build_name);
						build = new node(nullptr, plans.at(min_left), plans.at(min_right), stats);
					}
					else {
						build_name = combineName(plans.at(min_left)->main->name, plans.at(min_right)->main->name);
						node_stats *stats = new node_stats(min_rank, rank, best_pred, false, false, -1, build_content, build_name);
						build = new node(nullptr, plans.at(min_right), plans.at(min_left), stats);
					}
					plans.at(min_right) = plans.at(n);
					plans.at(min_left) = build;
				} // if is index
			}   // push
			if (pull) {
				for (int i = 0; i < build->main->content.size(); i++) {
					node *table = table_save.at(build->main->content.at(i));
					build->getBestPull(adj, build, table);
				}
			}
		} // main loop
		return plans[0];
	}
};

int main(int argc, char *argv[]) {
	// cout<<to_string(argc)<<endl;
	if (argc != 2) {
		cout << "Arguments must be: string filepath" << endl;
	}
	string filepath = "/home/simon/Desktop/qo/queries/fk-tree-0010-01";
	long double ratio = 0.0;
	for (int j = 1; j < 4; j++) {
		std::chrono::time_point<std::chrono::system_clock> dp_start, dp_end;
		std::chrono::duration<double> dp_duration = (std::chrono::duration<double>) 0.0;
		std::chrono::time_point<std::chrono::system_clock> goo_start, goo_end;
		std::chrono::duration<double> goo_duration = (std::chrono::duration<double>) 0.0;
		if (false) {
			for (int i = 1; i < 100; i++) {
				if (i < 10) {
					filepath = "/home/simon/Desktop/qo/queries/fk-tree-00" + to_string(j) + "0-0" + to_string(i);
				}
				else {
					filepath = "/home/simon/Desktop/qo/queries/fk-tree-00" + to_string(j) + "0-" + to_string(i);
				}
				long double dp_cost;
				parsed_file pf = parseFile(filepath);
				gooInput goo = generateGooInput(pf.pt, pf.pj, pf.ps);
				{
					DP dp(goo);
					dp_start = std::chrono::system_clock::now();
					auto result = dp.run();
					dp_end = std::chrono::system_clock::now();
					dp_duration += dp_end - dp_start;
					dp_cost = result->main->rank;
					// cout<<"DP: Kardinalität: " <<result->main->card<<" Kosten: "<<result->main->rank<<endl;
				}
				optimizer opt = optimizer(goo.size, goo.adj, goo.tables);
				goo_start = std::chrono::system_clock::now();
				node *result = opt.optimize(false, false, false);
				goo_end = std::chrono::system_clock::now();
				goo_duration += goo_end - goo_start;
				free(result);
				free(goo.adj);
				free(goo.tables);
				opt.freeOptimizer();
				// cout<<"GOO basic: Kardinalität: " <<result->main->card<<" Kosten: "<<result->main->rank<<endl;
				ratio += dp_cost / result->main->rank;
			}
			goo_duration /= 99.0;
			dp_duration /= 99.0;
			ratio /= 99.00;
			cout << ratio << "Step" << j * 10 << "dp" << dp_duration.count() << "goo" << goo_duration.count() << endl;
			ratio = 0.0;
			dp_duration = (std::chrono::duration<double>) 0.0;
			goo_duration = (std::chrono::duration<double>) 0.0;
		}
		if (true) {
			for (int i = 0; i < 10; i++) {
				long double dp_cost;
				gooInput goo = autoGeneratedGoo(j * 5);
				{
					DP dp(goo);
					auto result = dp.run();
					dp_cost = result->main->rank;
				}
				optimizer opt = optimizer(goo.size, goo.adj, goo.tables);
				goo_start = std::chrono::system_clock::now();
				node *result = opt.optimize(false, false, false);
				goo_end = std::chrono::system_clock::now();
				goo_duration += goo_end - goo_start;
				free(result);
				free(goo.adj);
				free(goo.tables);
				opt.freeOptimizer();
				// cout<<"GOO basic: Kardinalität: " <<result->main->card<<" Kosten: "<<result->main->rank<<endl;
				ratio += dp_cost / result->main->rank;
			}
			ratio /= 10.00;
			goo_duration /= 10.0;
			dp_duration /= 10.0;
			cout << ratio << "Step" << j * 5 << "dp" << dp_duration.count() << "goo" << goo_duration.count()endl;
			ratio = 0.0;
			dp_duration = (std::chrono::duration<double>) 0.0;
			goo_duration = (std::chrono::duration<double>) 0.0;
		}
	}

	return 0;
}
std::vector<int> combine(std::vector<int> v1, std::vector<int> v2) {
	for (int i = 0; i < v2.size(); i++) {
		v1.push_back(v2.at(i));
	}
	return v1;
}
long double hj(long double card1, long double card2, long double pred) {
	return card1 * card2 * pred;
}
long double ij(long double p1, int t2, long double sel, int lambda) {
	// t2 ohne single predicates
	//|p1 join t2| auch ohne single predicates in t2 ?
	// wie besprochen |p1|* max (|p1 join t2|/|p1|,1)*lambda
	long double max = hj(p1, (long double)t2, sel) / p1;
	if (max < 1.0) {
		max = 1.0;
	}

	return p1 * max * lambda;
}
long double getPred(long double **adj, const std::vector<int> &left, const std::vector<int> &right) {
	long double pred = 1.0;
	for (int i = 0; i < left.size(); i++) {
		for (int j = 0; j < right.size(); j++) {
			pred *= adj[left.at(i)][right.at(j)];
		}
	}
	return pred;
}
node *getBestPush(node *l, node *r, long double **adj) {
	pusheru r1 = l->getPush(l, r, adj);
	pusheru r2 = r->getPush(r, l, adj);
	if (r1.rank < r2.rank) {
		r1.n->applyPush(r, adj);
		return l;
	}
	else {
		r2.n->applyPush(l, adj);
		return r;
	}
}
std::string combineName(std::string left, std::string right) {
	return "(" + left + "X" + right + ")";
}
gooInput generateGooInput(std::vector<parsed_table> tables, std::vector<parsed_join> joins, std::vector<parsed_size> sizes) {
	gooInput result;
	result.size = tables.size();
	result.tables = new int[tables.size()];
	for (int i = 0; i < tables.size(); i++) {
		result.tables[i] = tables.at(i).unfilteredCardinality;
		// cout<< result.tables[i] <<endl;
	}
	// cout << "adj at initialization" <<endl;
	long double **adj = new long double *[tables.size()];

	for (int i = 0; i < tables.size(); i++) {
		adj[i] = new long double[tables.size()];
	}
	for (int i = 0; i < tables.size(); i++) {
		for (int j = 0; j < tables.size(); j++) {
			adj[i][j] = 1.0;
			// cout<<to_string(adj[i][j])+" ";
		}
		// cout<< "" <<endl;
	}
	for (int i = 0; i < tables.size(); i++) {
		adj[i][i] = tables.at(i).unfilteredCardinality / tables.at(i).cardinality;
		// cout<< to_string(adj[i][i]) << endl;
	}
	for (int i = 0; i < sizes.size(); i++) {
		parsed_size temp = sizes.at(i);
		int left = -1;
		int right = -1;
		for (int j = 0; j < tables.size(); j++) {
			if (temp.left.compare(tables.at(j).name) == 0) {
				left = j;
				// cout<< temp.left +" matches "+ tables.at(j).name <<endl;
				break;
			}
		}
		for (int j = 0; j < tables.size(); j++) {
			if (temp.right.compare(tables.at(j).name) == 0) {
				right = j;
				break;
			}
		}
		// axb * pred = card
		// pred = card/axb
		// cout<< "left: "+to_string(left)+" right: "+to_string(right)<<endl;
		long double pred = (long double)temp.cardinality / tables.at(right).cardinality;
		pred = pred / tables.at(left).cardinality;
		// cout << "cross: "+ to_string(pred)+ " cardinality "+to_string(temp.cardinality)+" left: "+
		// to_string(tables.at(left).cardinality)+" right: "+ to_string(tables.at(right).cardinality) <<endl;
		adj[left][right] = pred;
		adj[right][left] = pred;
	}
	for (int i = 0; i < tables.size(); i++) {
		for (int j = 0; j < tables.size(); j++) {

			// cout<<to_string(adj[i][j])+" ";
		}
		// cout<< "" <<endl;
	}
	result.adj = adj;
	return result;
}
parsed_file parseFile(string filepath) {
	parsed_file pf;
	//	string filepath = "/home/simon/Desktop/qo/queries/fk-tree-0010-01";
	// https://gist.github.com/komasaru/47f6df894e79f04f1a21
	// string filepath = argv[1];
	string line;
	string file;
	ifstream myfile(filepath);
	if (myfile.is_open()) {
		while (getline(myfile, line)) {
			file += line;
		}
		myfile.close();
	}
	else
		cout << "Unable to open file";
	const char *json = file.c_str();
	Document document;
	document.Parse(json);
	// https://rapidjson.org/md_doc_tutorial.html
	// check if root is object
	assert(document.IsObject());
	assert(document.HasMember("relations"));
	const Value &rel = document["relations"];
	assert(rel.IsArray());
	int size = 0;
	// from the doc
	static const char *kTypeNames[] = { "Null", "False", "True", "Object", "Array", "String", "Number" };
	std::vector<parsed_table> parsed_tables;
	// ich mach das hier doppelt für a reusability und SizeType parsen nicht intuitiv geht
	for (SizeType i = 0; i < rel.Size(); i++) {
		// vllt nicht für jedes objekt nötig :u
		assert(rel[i].IsObject());
		assert(rel[i].HasMember("name"));
		assert(rel[i].HasMember("baseTable"));
		assert(rel[i].HasMember("cardinality"));
		assert(rel[i].HasMember("unfilteredCardinality"));
		assert(rel[i]["name"].IsString());
		assert(rel[i]["baseTable"].IsString());
		assert(rel[i]["cardinality"].IsInt());
		assert(rel[i]["unfilteredCardinality"].IsInt());
		parsed_table parsed;
		parsed.name = rel[i]["name"].GetString();
		parsed.baseTable = rel[i]["baseTable"].GetString();
		parsed.cardinality = rel[i]["cardinality"].GetInt();
		parsed.unfilteredCardinality = rel[i]["unfilteredCardinality"].GetInt();
		parsed_tables.push_back(parsed);
		//	cout<<"name: "+parsed.name+ " baseTable: "+parsed.baseTable+"card: "+ to_string(parsed.cardinality) +" unfiltered "
		//+to_string(parsed.unfilteredCardinality)<<endl;
		size++;
	}
	pf.pt = parsed_tables;
	// sry aber ohne to string zeigt der das wirkl nich bei mir an
	// cout<<"relation size: "+to_string(size)<<endl;
	std::vector<parsed_join> parsed_joins;
	assert(document.HasMember("joins"));
	const Value &joins = document["joins"];
	assert(joins.IsArray());
	for (SizeType i = 0; i < joins.Size(); i++) {
		// cout<<kTypeNames[joins[i].GetType()]<<endl;
		parsed_join join;
		int side = 0;
		for (auto &v : joins[i]["relations"].GetArray()) {
			if (side == 0) {
				join.left = v.GetString();
			}
			else {
				join.right = v.GetString();
			}
			side++;
		}
		parsed_joins.push_back(join);
		//	cout<<"right: "+ join.right + "left: "+ join.left<<endl;
	}
	pf.pj = parsed_joins;
	std::vector<parsed_size> parsed_sizes;
	assert(document.HasMember("sizes"));
	const Value &sizes = document["sizes"];
	assert(sizes.IsArray());

	for (SizeType i = 0; i < sizes.Size(); i++) {
		// cout<<kTypeNames[joins[i].GetType()]<<endl;
		parsed_size size;
		int side = 0;
		for (auto &v : joins[i]["relations"].GetArray()) {
			if (side == 0) {
				size.left = v.GetString();
			}
			else {
				size.right = v.GetString();
			}
			side++;
		}
		size.cardinality = rel[i]["cardinality"].GetInt();
		parsed_sizes.push_back(size);
		// cout<<kTypeNames[joins[i]["relations"].GetType()]<<endl;
		// cout<<"right: "+ size.right + " left: "+ size.left + " card: " + to_string(size.cardinality)<<endl;
	}
	pf.ps = parsed_sizes;
	return pf;
}
gooInput autoGeneratedGoo(int size) {
	gooInput input;
	input.size = size;
	input.tables = new int[size];
	long double **adj = new long double *[size];
	std::default_random_engine generator;
	std::uniform_int_distribution<int> distribution(1, 6000);
	for (int i = 0; i < size; i++) {
		adj[i] = new long double[size];

		input.tables[i] = distribution(generator);
	}
	std::uniform_int_distribution<int> adj_dist(1, 10000);
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			adj[i][j] = adj[j][i] = (long double)adj_dist(generator) / 10000;
		}
	}
	input.adj = adj;
	return input;
}
